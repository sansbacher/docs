<!DOCTYPE html>
<html lang="en">

<head>
	<!-- Update these for each page -->
	<title>PowerShell CLI Boot Camp</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="keywords"
		content="command line,powershell,cmd,dos,console,shell,terminal,command,cmdline,commandline,howto,how-to,guide,commands,admin,administrator,windows,win32">
	<meta name="description" content="A commandline tutorial for PowerShell, CMD, and the CLI in general for Windows Admins">
	<meta name="author" content="Saul Ansbacher">
	<!-- Based on the "Material Design" W3.CSS Demo, with some changes, from www.w3schools.com. Simple and works. -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
	<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue-grey.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!-- Some custom CSS overrides, SCRIPT is loaded at the END: -->
	<link rel="stylesheet" href="../assets/css/sa-custom.css">
	<link rel="stylesheet" href="../assets/css/prism.css"> <!-- For Syntax highlighting of PRE CODE blocks -->
</head>

<body>
	<nav class="w3-sidebar w3-bar-block w3-collapse w3-animate-left w3-card" style="z-index:3;width:250px;" id="mySidebar">
		<a class="w3-bar-item w3-button w3-hide-large w3-large" href="javascript:void(0)" onclick="w3_close()">Close <i
				class="fa fa-remove"></i></a>
		<!-- Side Nav Bar items -->
		<a class="w3-bar-item w3-button" href="index.html">CLI Home</a>
		<a class="w3-bar-item w3-button" href="cli-basics.html">CLI Basics</a>
		<a class="w3-bar-item w3-button" href="ps-essentials.html">PowerShell Essentials</a>
		<a class="w3-bar-item w3-button" href="cmd-essentials.html">CMD/DOS Essentials</a>
		<a class="w3-bar-item w3-button" href="cli-keystrokes.html">CLI Keystrokes</a>
		<a class="w3-bar-item w3-button" href="cli-symbols.html">CLI Symbols</a>
		<a class="w3-bar-item w3-button" href="basic-file-sys-commands.html">Basic File Sys Commands</a>
		<a class="w3-bar-item w3-button" href="cli-tasktest.html">CLI Task Test</a>
		<a class="w3-bar-item w3-button" href="console-commands.html">Common Console Commands</a>
		<a class="w3-bar-item w3-button w3-theme" href="ps-bootcamp.html">PowerShell Boot Camp</a>
		<a class="w3-bar-item w3-button" href="cmd-bootcamp.html">CMD/DOS Boot Camp</a>
		<a class="w3-bar-item w3-button" href="additional-topics.html">Additional Topics</a>
		<a class="w3-bar-item w3-button" href="https://github.com/sansbacher/docs">Return to Docs</a>
	</nav>

	<div class="w3-overlay w3-hide-large w3-animate-opacity" onclick="w3_close()" style="cursor:pointer" id="myOverlay"></div>

	<button onclick="topFunction()" id="toTopButton" class="w3-button w3-theme-action" title="Go to top">Top</button>

	<div class="w3-main" style="margin-left:250px;">
		<!-- Main div for the body Start -->

		<!-- Change both of these to change the Page Header -->
		<div id="myTop" class="w3-container w3-top w3-theme w3-large">
			<p><i class="fa fa-bars w3-button w3-theme w3-hide-large w3-xlarge" onclick="w3_open()"></i>
				<span id="myIntro" class="w3-hide">PowerShell Command Prompt Boot Camp</span></p>
		</div>
		<header class="w3-container w3-theme" style="padding:64px 32px">
			<h1 class="w3-xxxlarge">PowerShell Command Prompt Boot Camp</h1>
		</header>

		<div class="w3-container" style="padding:32px;padding-right:5%">
			<!-- Page Content starts here -->

			<h2>A PowerShell Command Line Boot Camp</h2>

			<ul>
				<li><a href="#powershell-commands">PowerShell Commands</a></li>
				<li><a href="#three-useful-commands">The Three Most Useful Commands</a></li>
				<li><a href="#three-useful-concepts">The Three Most Useful Concepts</a></li>
				<ul>
					<li><a href="#concept-variables">Variables</a></li>
					<li><a href="#concept-objects">Objects</a></li>
					<li><a href="#concept-pipeline">The Pipeline</a></li>
				</ul>
				<li><a href="#advanced-control">Advanced Control Structures</a></li>
				<ul>
					<li><a href="#concept-foreach">Foreach</a></li>
					<li><a href="#concept-if-then">If ... Then</a></li>
					<li><a href="#concept-functions">Functions</a></li>
					<li><a href="#concept-write">Write vs Write-Host</a></li>
				</ul>
				<li><a href="#final-points">Final PowerShell Points</a></li>
				<ul>
					<li><a href="#concept-profile">Your $PROFILE</a></li>
				</ul>
			</ul>

			<p>This section will give a brief boot-camp / accelerated crash course to get up to speed on PowerShell quickly. It won't be
				very in depth, but it should provide enough info you can get by or at least search for more in-depth pages about a certain
				topic. It also won't teach you how to <i>program</i> scripts or some of the PowerShell best practices or gotchas - it's a
				basic "get started fast" guide. This overall guide was mainly just about the Command Line in general, but once you know the
				basics you want to start learning more - start here!</p>

			<p>I assume you can complete the <a href="cli-tasktest.html">CLI Task Test</a>, if not run through Zen's <a
					href="https://learnpythonthehardway.org/book/appendixa.html" target="_blank">CLI Crash Course</a> first. Most what you
				may know about the CMD/"DOS" Prompt may also be useful. This will just be a surface-level guide, not a deep-dive. Enough to
				help point you in the right direction and know what to Google if you get stuck. For the basics see the <a
					href="ps-essentials.html">PowerShell Essentials</a> page.</p>

			<h3 id="powershell-commands">PowerShell Commands</h3>

			<p>PowerShell commands (officially called cmdlets) are generally always of the form <i>Verb-Noun</i> or <i>Action-Subject</i>,
				and the Noun or Subject will have several Verb/Action related commands, such as <code>Get-Content</code>,
				<code>Set-Content</code>, <code>Add-Content</code>, and <code>Clear-Content</code> to get the contents of a file, write a
				file, add to a file, and empty a file.
			<ul>
				<li><code class="console">Get-*</code> commands are usually always safe to run as they just <i>retrieve</i> some information
				</li>
				<li><code class="console">Set-*</code> commands are used to <i>change</i> or to <i>set</i> some value(s)</li>
				<li><code class="console">New-*</code> commands are used to <i>create</i> something new (like a folder or other object)</li>
				<li><code class="console">Remove-*</code> commands <i>delete</i> something</li>
				<li>Not every Verb is available (or would make sense) for every Noun/Subject, but usually they are in matched pairs, such as
					Get-/Set- or Export-/Import-, etc<br>
					There are many standard Verbs, try <code>Get-Verb</code> to see them all - but people still use non-standard Verbs too.
				</li>
			</ul>
			</p>

			<p>PowerShell commands/cmdlets always use a single dash <kbd>-</kbd> to indicate options/parameters/switches/arguments, such as
				<code class="console">-Identity</code> or <code class="console">-Properties</code>. Any value comes after, such as: <code
					class="console">-Identity jsmith</code>. PowerShell commands/cmdlets and options/parameters are <i>not</i> case
				sensitive, but usually displayed using PascalCase so words forced together AreEasierToRead. Cmdlets and Parameters are often
				long so use <a href="ps-essentials.html#tab-completion"><kbd>Tab</kbd> Completion</a>.</p>

			<p>PowerShell cmdlets come in various modules: many of which are included with Windows/PowerShell, come with other programs
				(like Active Directory or SQL Server), or can be downloaded from the <a href="https://www.powershellgallery.com/"
					target="_blank">PowerShell Gallery</a>. Load a module with <code>Import-Module</code> (though often just using a cmdlet
				will auto-load the module in PowerShell 3.0+) and install a module with <code>Install-Module</code>. See all the modules
				installed on your system with: <code>Get-Module -ListAvailable</code><br>
				&nbsp; &rarr; Sometimes there are prefixes to the Nouns/Subjects to group commands, such as <code>Get-ADUser</code>,
				<code>Set-ADComputer</code>, <code>Remove-ADGroup</code> each having an "AD" prefix.</p>

			<hr>
			<h3 id="three-useful-commands">The Three Most Useful Commands</h3>

			<p>Because PowerShell is very regular and discoverable the 3 most useful commands to initially learn are listed here:</p>

			<ul class="w3-ul">
				<li>
					<p><code>Get-Help</code> (alias = <code>help</code>) to display the Help Text for any command, cmdlet, or just about
						anything. Using <code class="console">-full</code> will usually give you detailed help and examples, such as:
						<code>help get-content -full</code> (you can skip right the examples with <code class="console">-Examples</code>, as
						in: <code>help get-content -examples</code>). See the <a href="ps-essentials.html#get-help">Essentials</a> page for
						more details.
					</p>
					<p>
						You can also get help on various internal aspects of PowerShell, they all start with <i>about_</i> such as
						<code>help about_variables</code> or try <code>help about_</code> to see a list of all internal help files.</p>
				</li>

				<li>
					<p><code>Get-Command</code> (alias = <code>gcm</code>) to search for and find various commands, cmdlets, functions, etc.
						Similar to CMD's <code>where.exe</code> but with much more flexibility and fine-grained control. You can use <code
							class="console">-CommandType</code> to search for only certain commands or functions, or <code
							class="console">-Module</code> to limit searching to a certain Module as in
						<code>gcm -module ActiveDirectory</code>
					</p>
					<p>
						But just filtering on the Name is simplest: see all the "Get-" commands on your system try <code>gcm get-*</code> or
						if you want to see all Verbs/Actions you can perform on Services try: <code>gcm *-Service</code> or to see any
						command pertaining to "computers" try <code>gcm *computer*</code></p>
				</li>

				<li>
					<p><code>Get-Member</code> (alias = <code>gm</code>) to get all the <i>Properties</i> and <i>Methods/Functions</i> that
						are returned from a command/cmdlet or belonging to a <i>Type</i> or <i>Variable</i>. Because PowerShell is "all
						objects" every <i>Object</i> can have hidden Properties (values) or Methods/Functions (actions you perform). Most of
						these are all .NET based since PowerShell relies on the .NET Framework (or .NET Core).</p>
					<p>A command like <code>Get-Date</code> returns the current Date and Time, but the value returned isn't just a text
						string of characters, you can see the Type and all the various Properties and methods with:
						<code>Get-Date | gm</code> which will show that its Type is <i>System.DateTime</i>, and it has over 50 Properties
						and Methods that contain just the Seconds, Hours, Days, or Months and let you convert the DateTime to different
						formats or Add days, hours, months, etc to get a new DateTime. (we'll see how to access these Properties/Methods
						below)</p>
				</li>
			</ul>

			<hr>
			<h3 id="three-useful-concepts">The Three Most Useful Concepts</h3>

			<p>Relatedly, the 3 most useful concepts in PowerShell are: Variables, Objects, and the Pipeline. We'll cover these in greater
				detail in the next sections.</p>

			<h4 id="concept-variables">Variables</h4>

			<p>Since everything is an <i>Object</i> (which will be discussed in the next section): a PowerShell command can return a lot of
				data, you can use <i>Variables</i> to store this data and access it again later; or create your own variables to avoid
				having to re-type the same thing over and over. There are some built-in and automatic variables. Think of a variable as a
				bucket with a label: the label is the name of the variable and the bucket holds the value. You retrieve the value by
				referencing the bucket by the name on the label. If you change the contents of the bucket: anywhere after it is referenced
				by name will use the new value.</p>
			<ul>
				<li>Variable names always start with a dollar sign <kbd>$</kbd>, such as <code class="console">$Username</code> or <code
						class="console">$SomeLocation</code></li>
				<li>You create a variable by assigning a value to the name with the equals sign <kbd>=</kbd> such as:
					<code>$Username = "jsmith"</code> or <code>$SomeLocation = "c:\temp\folder"</code></li>
				<li>You can also fill a variable with the results of a command, such as: <code>$today = Get-Date</code> (the right hand side
					is evaluated first and then assigned to the variable on the left)</li>
				<li>To use a variable just use its name (eg. <code class="console">$SomeLocation</code>) such as:
					<code>$ListOfFiles = dir $SomeLocation</code> (now <code class="console">$ListOfFiles</code> will contain a list of all
					the files located in <code class="console">$SomeLocation</code>)</li>
				<li>One special built-in variable is <code class="console">$null</code> which represents <i>nothing</i> or an empty
					variable, you can clear a variable by setting it to <code class="console">$null</code> such as:
					<code>$Username = $null</code></li>
			</ul>

			<p>Often a cmdlet will return more than one value (such as many files in a directory, many AD Users, many Processes, etc) in
				those cases the results will be an <i>Array</i> which is List or Collection of items. An Array can also be assigned to a
				variable in exactly the same way. However the variable name (eg. <code class="console">$ListOfFiles</code>) will point to
				the Array, not one particular item in the array. To select just one item from the Array you use an <i>Index</i> number -
				which starts at 0, in <i>[square brackets]</i> after the Array variable name.</p>
			<ul>
				<li>Thus if <code class="console">$ListOfFiles</code> has has 10 files, then the first is <code
						class="console">$ListOfFiles[0]</code> and the last (the 10th) is <code class="console">$ListOfFiles[9]</code></li>
				<li>Always be mindful that Array indexes run from 0 to <i>Total - 1</i></li>
				<li>Think of an Array as a clothesline with a bunch of variable buckets hanging from it. The clothesline has a label with
					the name of the array, and each bucket has only a number on its label.</li>
			</ul>

			<p>It's also worth briefly noting that variables have a <i>Type</i> in addition to a <i>Name</i> and a <i>Value</i> - the Type
				is the sort of Value the bucket holds. Common types are <i>String</i> (a sequence of characters, <i>"such as a sentence in
					quotes"</i>), <i>Int</i> (for Integer, a number without a decimal place: <i>0, 1, -6, 689</i>, but not 1.5 or 3.14),
				<i>Float</i> (for floating point, a number with a decimal place: <i>0.0002, -0.5, 1.11178, 2.0, 3.14</i>), <i>Boolean</i> (a
				value that is only either <code class="console">$True</code> or <code class="console">$False</code> - two special variables
				that represent <i>True</i> or <i>False</i>), <i>DateTime</i> (a Date and/or Time value, such as returned by
				<code>Get-Date</code>), and any other valid .NET type. Think of the Type as the Colour of the variable bucket: there's a
				name of a variable but also a colour denoting if it's holding text, numbers, dates, etc.
			</p>
			<ul>
				<li>Normally the Type is not important as PowerShell has Dynamic Typing and will convert between types as needed.</li>
				<li>But sometimes you need to be explicit about the Type or you need to be aware of the Type or you could find strange
					things happening.</li>
				<li>For example: 5 is an Int (integer number) but <code class="console">"6"</code> is a very short 1-character String. Try
					adding them to together in PowerShell, note the order makes a difference: (you can just type these at the <code
						class="console">PS C:\></code> prompt.<br>
					<code>5 + "6" = 11</code> (because "6" is converted to the number 6), but <code>"6" + 5 = "65"</code> (because now 5
					gets converted to the string "5" and concatenated/appended to "6" creating a 2-character String)</li>
				<li>An <i>Array</i> is a Type as well: an Object that is a List or Collection of other Variables</li>
			</ul>

			<h4 id="concept-objects">Objects</h4>

			<p>If PowerShell is all about Objects, what's an Object? An <i>Object</i> is "Structured Data + Methods to work with that Data".
				Think of an Object as a Large Bucket with several smaller Buckets inside plus the Tools to "do things with those buckets".
				The smaller buckets are <i>Properties</i> (the Data - basically a bunch of related variables) and the Tools are
				<i>Methods</i> (or Functions, that can do things with the Properties/variables). Objects are structured because every Object
				also has a Type and all Objects of the same Type follow the same structure, like a Template (having the same Properties and
				Methods available as the Template they were created from).</p>

			<p>Object variables have their name on the Large Bucket that you can pick (like <code class="console">$UserObject</code>) but
				the Property and Method names are set by the template Type for that sort of Object.<br>
				You can reference the Properties and Methods with "dot notation" - by using the Object's variable name, a dot <kbd>.</kbd>,
				and the
				Property or Method. Eg: <code class="console">$Object.Property</code> or <code class="console">$Object.Method()</code><br>
				&nbsp; &rarr; Properties are just variables and hold values, sometimes you can <i>set</i> them, other times you can only
				<i>get</i> them (if they are read-only).<br>
				&nbsp; &rarr; Methods are <i>functions</i> that perform actions, possibly returning a value; you need to use
				<i>(parentheses)</i> to call a function, and pass any parameters inside the parentheses like: <code
					class="console">$Object.Method(parameter1, parameter2)</code></p>

			<ul>
				<li>Example Properties on an <i>AD User object</i> returned from <code>Get-ADUser</code>, such as:
					<code>$UserObject = Get-ADUser -Identity jsmith</code> might be:<br>
					<code class="console">$UserObject.Surname</code> might return "Smith"<br>
					<code class="console">$UserObject.GivenName</code> might return "Jane"</li>
				<li>Example Methods on a <i>DateTime object</i> returned from <code>Get-Date</code>, such as <code>$Today = Get-Date</code>
					might be:<br>
					<code class="console">$Today.ToString()</code> would return the date and time you ran Get-Date such as "2/24/2020
					10:20:42 PM"<br>
					But <code class="console">$Today.ToString("yyyy-MM-dd")</code> would tell the ToString() function to return only the
					date in YYYY-MM-DD format, such as "2020-02-24"<br>
					And <code class="console">$Today.AddDays(4)</code> would return the date exactly 4 days from now on Feb 28.</li>
				<li>It's very common to have an <i>Array of Objects</i> (since almost everything except simple Strings and numbers are
					Objects). As the Array type is also an Object itself it has Properties and Methods too! One of the most useful
					Properties of an Array is the Length - how many items are in the Array<br>
					If <code class="console">$ListOfFiles</code> is an Array of 10 items/files then <code
						class="console">$ListOfFiles.Length</code> would return 10<br>
					But note: the last/final <i>Index</i> of the Array would still be <code class="console">$ListOfFiles[9]</code>. The
					Length is a count of how many items there are, starting at 1: it could be 0 (for no items), or 1, 2, 3, 10, or hundreds
					of items. But the <i>Index</i> runs from <i>[0]</i> to <i>[Length -1]</i></li>
			</ul>

			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					You can use <code>Get-Member</code> to see all the Properties and Methods an Object contains.<br>
					Can you convert an Int (number) to a String? Can you add years to a DateTime? Is there an Email Address Property on an
					AD User Object?<br>
					Use <code>Get-Member</code> to find out! Example: <code>$UserObject | Get-Member</code>, or
					<code>Get-Member -InputProperty $Today</code>, or even: <code>12345 | Get-Member</code>
				</p>
			</div>

			<br>
			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<p>Often you need to access Properties, Methods, or even just evaluate a PowerShell expression, variable or command
				<i>within</i> another command or context. You can use sub-expressions to do this by enclosing the
				command/variable/expression
				in brackets like: <code class="console">(Some-Command)</code> and then you can access Properties/Methods, like: <code
					class="console">(Some-Command).OneProperty</code></p>

			<ul>
				<li>You <b>can't</b> do: <i>Get-Date.ToString("yyyy-MM-dd")</i></li>
				<li>So you can either assign <code>Get-Date</code> to a variable such as <code class="console">$Today</code> (see above),
					<b>or</b> enclose it in brackets: <code>(Get-Date).ToString("yyyy-MM-dd")</code></li>
				<li>You can access Properties too: <code>(Get-ADUser -Identity jsmith).Surname</code></li>
				<li>If there's more than one command inside the brackets, OR the command is inside a "double quoted string" then add a
					dollar sign <kbd>$</kbd>to the front:
					<code>"Today's date is $($Today = Get-Date; $Today) and tomorrow is $($Today.AddDays(1))."</code><br>
					Note: if you want to use Variables within Strings you need to use <i>"double quotes"</i>, if you use <i>'single
						quotes'</i> you'll see the name of the variable instead</li>
			</ul>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-light w3-threequarter">
					<h5>An Example of Variables with "double" and 'single' quotes:</h5>
					<div class="w3-code notranslate">
						PS C:\> $Today = Get-Date<br>
						PS C:\> # With "double quotes" it will resolve the $Today variable:<br>
						PS C:\> "It is $Today"<br>
						It is 02/24/2020 12:13:17<br>
						PS C:\> # With 'single quotes' it will print exactly as written:<br>
						PS C:\> 'It is $Today'<br>
						It is $Today<br>
					</div>
				</div>
			</div>

			<h4 id="concept-pipeline">The Pipeline</h4>

			<p>The PowerShell <i>Pipeline</i> is what allows you to link commands (or Variables) together to process, filter, or otherwise
				do something with the values. The Pipeline is denoted by the vertical bar or Pipe character: <kbd>|</kbd>, which separates
				commands/cmdlets, expressions or variables. Each section of the Pipeline feeds the next: <i>the Output of one command
					becomes the Input of the next</i>. Almost all PowerShell commands/cmdlets and many scripts output Objects that can be
				accepted as input via the Pipeline by other commands/cmdlets/scripts - the Pipeline passes Objects. You can think of it as
				an unnamed Array of Objects where the current Object is represented by the special variable: <code class="console">$_</code>
				though often you don't need to reference individual elements of the Pipeline since by default commands will work on
				<i>all</i> elements of the Pipeline. Usually a command changes or filters (narrows) the Output as compared to the Input. You
				can have as many 'sections' of the Pipeline as you want, but unwieldy commands can be shortened by using Variables. Be
				careful mixing non-PowerShell (regular Windows Console CMD commands) and the PowerShell Pipeline: non-PowerShell commands
				output plain text, <i>not</i> objects!</p>

			<p>Some common simple commands that work with the Pipeline are: <code>Sort-Object</code>, <code>Measure-Object</code>,
				<code>Group-Object</code> (usually just referenced by their aliases: <code>Sort</code>, <code>Measure</code>, and
				<code>Group</code>). By default the final result of the Pipeline is displayed on the screen, so you'll see the results.
			<ul>
				<li>How many files in a folder: <code>dir c:\windows | Measure</code></li>
				<li>Files ordered by size: <code>dir c:\windows | Sort Length</code></li>
				<li>How many of each file type: <code>dir c:\windows | Group Extension | Sort Name</code></li>
			</ul>
			</p>

			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					Remember you can use <code>Get-Command</code> to see what other commands deal with "Objects", such as
					<code>Get-Member *-Object</code>
				</p>
			</div>

			<p>Other common Pipeline commands involve displaying information: <code>Format-List</code>, <code>Format-Table</code> (usually
				just <code>fl</code> and <code>ft</code>), <code>Out-String</code> or <code>Out-GridView</code> -- these almost always come
				at the end of the Pipeline:
			<ul>
				<li>List more details on files: <code>dir c:\windows | fl</code> (you can still add <code class="console"> | more</code>
					after to show a page at a time)</li>
				<li>They can be combined and displayed in a pop-up window: <code>dir c:\windows | sort Length | Out-GridView</code></li>
			</ul>
			Because of the regular and non-cryptic nature of PowerShell you can probably guess what most of these do even without using
			<code>help</code> with them. For example, the last one is literally "directory of C:\Windows, sorted by file Length, whose
			output goes into a GridView (a kind of pop-up list of data window)"
			</p>

			<p>Saving/exporting (or reading/importing) data to/from files using Pipeline data is possible too: <code>Set-Content</code>,
				<code>Add-Content</code>, <code>Out-File</code>, <code>Export-Csv</code>, <code>Get-Content</code>, <code>Import-Csv</code>,
				<code>ConvertTo-Html</code>, and <code>ConvertFrom-Json</code> -- usually you want the raw data to be exported, so
				<i>don't</i> place these after <code>Format-List</code> or <code>Format-Table</code>
			<ul>
				<li>Save the results to a file as .TXT or a .CSV: <code>dir c:\windows | Set-Content c:\temp\output.txt</code> OR
					<code>dir c:\windows | Export-Csv -NoType c:\temp\output.csv</code></li>
				<li>You can load the .CSV file back with: <code>$Results = Import-Csv c:\temp\output.csv</code></li>
			</ul>
			</p>

			<p>Remember, use <code>Get-Help</code> (maybe with <code class="console">-Full</code> or <code class="console">-Examples</code>)
				to look up what these commands do, what the Required or Optional parameters do (such as what <code
					class="console">-NoType</code> does for <code>Export-Csv</code> -- remember you only need to specify enough to uniquely
				identify parameters). </p>

			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<p>Two of the most important, and common, <i>Pipeline</i> commands are <code>Where-Object</code> (or just <code>Where</code>, or
				even just a single question mark <kbd>?</kbd> as an alias) which <i>filters which Objects to pass along the Pipeline</i>
				(that is: only pass along Objects which match some search/filter criteria). And <code>Select-Object</code> (or just
				<code>Select</code>) which <i>filters which Properties of Objects are passed along the Pipeline</i> (that is: only pass
				along Properties that are listed, no others).<br>
				&nbsp; &rarr; <code>Where</code> filters Objects, <code>Select</code> filters Properties (of Objects)<br>
				Combined with other commands you can filter/choose which Objects or Properties to keep and which to discard, depending on
				what you want to do.</p>

			<p><code>Where</code> uses either the older/classic script-block format (which still allows more complex filters) or the newer
				(PS 3.0+) native format. In either case you choose aspects (usually Properties) of Objects and those Objects that match are
				passed along and those that don't are discarded.
			<ul>
				<li>You will need to use one or more <i>Operators</i> such as <code class="console">-and</code>, <code
						class="console">-or</code>, <code class="console">-not</code> (or the exclamation <kbd>!</kbd> character), <code
						class="console">-eq</code> (equals), <code class="console">-ne</code> (not equals), <code class="console">-gt</code>
					(greater than), <code class="console">-ge</code> (greater than or equal to), <code class="console">-lt</code> (less
					than), <code class="console">-le</code> (less than or equal to), <code class="console">-like</code>, <code
						class="console">-notlike</code>, <code class="console">-contains</code>, <code class="console">-in</code>, and
					several others. These work like in algebra and return <code class="console">$True</code> or <code
						class="console">$False</code>.<br>
					In the same way that <i>5 > 3 = True</i>, <code>5 -gt 3</code> is <code class="console">$True</code> (because 5 is
					greater than 3).<br>
					They all start with a dash: <kbd>-</kbd>. More information on <a href="https://ss64.com/ps/syntax-compare.html"
						target="_blank">Comparison Operators</a>.</li>
				<li>New <code>Where</code> format: <code>dir c:\windows | Where LastWriteTime -lt "2019/01/01" | Measure</code> (to see how
					many old files there are)</li>
				<li>Older <code>Where</code> format: <code>dir c:\windows | Where {$_.LastWriteTime -lt "2019/01/01"} | Measure</code> (note
					the <code>Where</code> filter is in <i>{curly braces}</i> and needs <code class="console">$_</code> to reference Objects
					in the Pipeline)</li>
			</ul>
			</p>

			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					<b>Note</b>, in PowerShell 'equals', 'not equals', 'greater than', and 'less than' are consistent in using
					<i>-something</i> because =, &gt;, and &lt; are used to assign variables or redirect output.<br>
					You cannot use also them to check if something is equal or greater than something. Use <code class="console">-eq</code>,
					<code class="console">-ne</code>, <code class="console">-gt</code>, <code class="console">-lt</code>, etc
				</p>
			</div>

			<p><code>Select</code> uses names of Properties (including partial matches using wildcards, where <kbd>*</kbd> = any characters)
				to filter what results get passed along. You can list one or more Properties, or Expand a Property if it contains multiple
				values or SubProperties; or choose just the First or Last number of items, or only return Unique values from a
				collection/array of Objects. Generally all the Objects are passed along, just not all their Properties - use
				<code>Where</code> to filter whole Objects.</p>

			<p>
			<ul>
				<li>To see only certain Properties (including one, like <i>FullName</i>, that isn't displayed by default):
					<code>dir C:\Windows | select Name, Fullname, LastWriteTime</code></li>
				<li>To see all the various "Time" Properties: <code>dir C:\Windows\notepad.exe | select Name, *Time*</code><br>
					With more than 4 properties often the default output style becomes List (aka <code>Format-List</code> or
					<code>fl</code>) rather than Table (aka <code>Format-Table</code> or <code>ft</code>), so seeing one item is easier than
					all.<br>
					Most Cmdlets have a default set of Properties to display, using <code class="console">| select *</code> you can see them
					<i>all</i>.</li>
				<li>To see all the available Properties: <code>dir C:\Windows\notepad.exe | select *</code></li>
				<li>If a Property has multiple values or SubProperties (often appearing as just a Type) you can dig deeper, compare these:
					<code>dir C:\Windows\notepad.exe | select VersionInfo</code> and
					<code>dir C:\Windows\notepad.exe | select -expand VersionInfo</code><br>
					And even <code>dir C:\Windows\notepad.exe | select -expand VersionInfo | select *</code></li>
				<li>You can also limit by <code class="console">-First</code> or <code class="console">-Last</code>, such as:
					<code>dir c:\windows | select -last 3</code></li>
				<li>Finally, you can use <i>Calculated Properties</i> with <code>Select</code> (especially useful with
					<code>Export-Csv</code> if you see a Type or something else unhelpful, but it displays correctly at the Console because
					it's multi-valued). Calculated Properties require a <i>Hashtable</i> with <i>Name</i> and <i>Expression</i> Keys (we
					haven't covered Hashtables, they're similar to Arrays but are made up of <i>Key/Value pairs</i>). An example would
					be:<br>
					<code>dir c:\windows | select Name, @{ Name = 'LastWriteDay'; Expression = {$_.LastWriteTime.ToString("yyyy-MM-dd")} }, LastWriteTime</code><br>
					Which displays the Name and the usual LastWriteTime, but also a new, Calculated Property, called <i>LastWriteDay</i>
					which is only the Date portion of LastWriteTime.</li>
				<li>Many, but not all, of <code>Select</code>'s functions can be done directly with <code>ft</code> / <code>fl</code> as a
					convenience, this avoids needing to do: <code>dir | select Name, LastWriteTime | fl</code>, you can just do:
					<code>dir | ft Name, LastWriteTime</code></li>
			</ul>
			</p>

			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					<b>Note</b>, because <code>Select-Object</code> is all about Objects it can get you into trouble if you to try to use it
					with the output from regular Windows Console CMD .EXE commands.<br>
					Non-PowerShell commands output plain-text, which isn't Objects. To filter plain-text strings use
					<code>Select-String</code> (alias is <code>sls</code>).<br>
					Where <code>manage-bde.exe -status c:</code> will show the BitLocker status of the C: drive, you CAN'T filter on the
					"<i>Conversion Status: &nbsp; &nbsp;Fully Decrypted</i>" line with this:<br>
					<code>manage-bde.exe -status c: | select "Conversion Status"</code><br>
					But you CAN with <code>Select-String</code>:<br>
					<code>manage-bde.exe -status c: | select-string "Conversion Status"</code>
				</p>
			</div>

			<hr>
			<h3 id="advanced-control">Advanced Control Structures</h3>

			<p>PowerShell has many advanced control structures as well, but because this document is about the basic Command Line usage and
				not Programming/Scripting we'll just mention a few here. You will need to learn these (especially <code>foreach</code> and
				<code>if</code>) to create scripts or solve more advanced problems with PowerShell. For now, focus on being comfortable with
				PowerShell and the Command Line in general.</p>

			<hr>
			<h4 id="concept-foreach">Foreach</h4>

			<p>The Pipeline <i>cmdlet</i>: use the <code>Foreach-Object</code> (or the aliases: <code>foreach</code> or even just the
				percent sign
				<kbd>%</kbd> by itself) to do something to everything in an Array/Collection in the Pipeline, where <code
					class="console">$_</code> represents the current Item/Object being processed, like with <code>Where</code>, for example:
				<code>dir | foreach { write "Here is a file: $($_.Name)" }</code>. Note: the default action of the Pipeline is to pass all
				objects to the next command, so you only need <code>foreach</code> if you want to accomplish something specific with each
				item.</p>

			<p>The confusingly named PowerShell <i>statement</i>: <code>foreach</code> which is very similar to <code>Foreach-Object</code>
				(especially since alias for one is the same as the other - PowerShell figures out which) but the <code>foreach</code>
				doesn't use the Pipeline but names each item it works on (the <code class="console">$file</code> variable in the example
				below) instead of using <code class="console">$_</code>.</p>

			<p>Which <code>foreach</code> method you use doesn't matter a lot, one will make more sense in some situations and the other in
				other situations. Use whichever makes the most sense at the time - ie. are you working with data in the Pipeline? Within
				.PS1 scripts the <code>foreach</code> statement is often used to do multiple things to each item in the array. Have a look
				at
				the example below - they both produce the same output.</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-light w3-threequarter">
					<h5>An example of Foreach-Object and foreach statement:</h5>
					<div class="w3-code notranslate">
						PS C:\> $AllFiles = dir c:\windows<br>
						PS C:\> # With the Foreach-Object cmdlet you process via the pipeline (input and output):<br>
						PS C:\> $AllFiles | foreach { write "Here is a file: $($_.Name)" }<br>
						Here is a file: addins<br>
						Here is a file: ADFS<br>
						Here is a file: etc, etc<br>
						PS C:\> # With the foreach statement you declare a variable to work with the Array, no Pipeline:<br>
						PS C:\> foreach ($file in $AllFiles) { write "Here is a file: $($file.Name)" }<br>
						Here is a file: addins<br>
						Here is a file: ADFS<br>
						Here is a file: etc, etc<br>
					</div>
				</div>
			</div>

			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<hr>
			<h4 id="concept-if-then">If ... Then</h4>

			<p>The conditional <code>IF</code>/<code>ELSE</code> statement, which uses <i>Conditionals</i> like <code>Where</code> does, is
				used for branching and making logical decisions (often called <i>If ... Then ...</i> statements). You can decide to do
				something IF a certain condition is true or ELSE do another thing.<br>
				A script that is just a collection of commands saves you from having to type them over and over, a script
				that uses
				variables is more flexible and easier to maintain and update, a script that uses loops (such as above) can do the same thing
				to all
				Objects in an Array without repeating lines - but a script that can make <i>decisions</i> can be very powerful (eg. Install
				X, if successful do Y, else do Z).
				An example of a simple <code>if</code> is below:</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-light w3-threequarter">
					<h5>An Example of an IF / ELSE Condition:</h5>
					<div class="w3-code notranslate">
						PS C:\> $value = 35<br>
						PS C:\> # Use IF to decide what to print:<br>
						PS C:\> if ($value -lt 20) { write "$value is a small number" } else { write "$value is a big number" }<br>
						25 is a big number<br>
					</div>
				</div>
			</div>

			<br>
			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					Note: in the above two examples (for <code>foreach</code> and <code>if</code>) there's a <i>Script Block</i> in
					<i>{curly braces}</i> with commands that are run.<br>
					You can have multiple commands within Script Blocks, separated by semi-colons <kbd>;</kbd> or within a .PS1 script by
					putting commands on separate lines.<br>
				</p>
			</div>

			<p>Here is an example of a small script which has several lines within a script block, you can copy and paste it into a <class
					id="console">.PS1</class>
				file and run it:</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-l3 w3-threequarter">
					<h5>Multi-line script blocks</h5>
					<pre><code class="language-powershell"># Tells you if a number is larger or smaller than 20
$MyArray = 5, 10, 15, 20, 25, 30, 35, 40
write "Starting..."
foreach ($Number in $MyArray) {
	# Several lines inside the foreach {script-block}
	if ($Number -lt 20) {
		write "$Number is smaller than 20"
	} elseif ($Number -eq 20) {
		# several lines inside this if/elseif script-block
		write "-=-=-=-=-=-=-"
		write "$Number IS Twenty!!"
		write "-=-=-=-=-=-=-"
	} else {
		write "$Number is larger than 20"
	}
}
write "All done."
</code></pre>
				</div>
			</div>

			<p>Note that the above example also included <code>ELSEIF</code> which lets you stack several conditions into one
				<code>IF</code> statement (IF this, ELSEIF that, ELSEIF another ELSE final option).</p>

			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<p>Other control structures include <code>For</code> loops, <code>Do</code> <code>While</code> or <code>Until</code> loops,
				<code>Switch</code>
				statements, and <i>Functions</i>. Most of these are beyond the scope of this document, and probably not anything you'll need
				right away.
				But custom <i>functions</i> allow you to encapsulate common commands into a subroutine you can re-use - and keep your code
				tidy.
			</p>

			<hr>
			<h4 id="concept-functions">Functions</h4>

			<p>
				Functions are blocks of code that you can use and re-use within your code. You can define Functions on the command line or,
				more commonly,
				within scripts (<code class="console">.PS1</code> files) -- they are like mini scripts within scripts. You can define and
				pass parameters
				to functions, and they can return values (but they don't have to). Any value that is output within a Function is returned
				when the Function
				exits. This allows you to assign the output of a function to a variable, like: <code
					class="console">$var = My-Function</code>.</p>

			<p>
				In many languages you need an explicit <code>return</code> keyword, but it's
				optional in PowerShell - where <i>any</i>
				output in the Pipeline
				is returned. This often causes headaches for people coming from other scripting languages, so it's worth pointing it out (in
				case
				you are used to
				another programming/scripting language like JavaScript, Python, C/Java, etc).
			</p>

			<p>
				To create a Function just use the <code>function</code> keyword, the <i>name</i> of the function, and put any
				<i>optional</i> parameters you
				want in (brackets). Then put your code in {curly braces} after - called a script-block. It's best to follow the standard
				<i>Noun-Verb</i>
				naming convention. There's a lot more you can do with functions, including supporting the <code>help</code> command or
				validating parameters with
				<a href="https://ss64.com/ps/syntax-function-advanced.html" target="_blank">Advanced Functions</a> which can also allow you
				to accept
				Pipeline input. Functions don't have to be long, they can be short and just save you from typing the same code over and
				over.
			</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-light w3-threequarter">
					<h5>Two example functions:</h5>
					<div class="w3-code notranslate">
						PS C:\> # You can enter functions on one line in the Console, or across several lines in a script.<br>
						PS C:\> # See the current date:<br>
						PS C:\> Get-Date<br>
						Tuesday, June 9, 2020 10:26:07 PM<br>
						PS C:\> # Define a function with no parameters:<br>
						PS C:\> function Get-Tomorrow { (Get-Date).AddDays(1) }<br>
						PS C:\> # Test it:<br>
						PS C:\> Get-Tomorrow<br>
						Wednesday, June 10, 2020 10:26:20 PM<br>
						PS C:\> # Define a function with a parameter and then assign the results to a variable:<br>
						PS C:\> function Get-FutureDate ($Days) { (Get-Date).AddDays($Days) }<br>
						PS C:\> $NextWeek = Get-FutureDate -Days 7<br>
						PS C:\> $NextWeek<br>
						Tuesday, June 16, 2020 10:26:45 PM<br>
					</div>
				</div>
			</div>

			<ul>
				<li>It's important to know: <code>Write "Some text."</code> will output via the Pipeline (and by default display on the
					screen), whereas <code>Write-Host "Some text."</code> will not output via the Pipeline - it displays directly on the
					Console screen.</li>
				<li>A common cause of frustration with Functions is not understanding that they are designed to <i>work with the
						Pipeline</i> and getting unexpected output returned is a common mistake by mixing up <code>write</code> and
					<code>write-host</code><br>
					See below for more on <code>Write-Host</code> verses <code>Write</code>.</li>
				<li>And while there is a <code>return</code> statement it's not needed as <i>anything</i> output to the Pipeline (such as by
					<code>write</code> or from a command) is returned by a function.</li>
				<li>Also: unlike calling a Method on an Object you don't use <i>(brackets)</i> when calling functions. They are like
					cmdlets, you
					just pass arguments like:<br>
					<code>My-Function $Param1 "value 2" -Switch3</code> do not do this: <i>My-Function ($Param1, "value 2", -Switch3)</i> -
					that will create an Array!<br>
					Note: You can optionally skip <code class="console">-parameter</code> name with a function or cmdlet if you match the
					order of the arguments</li>
			</ul>

			<div class="w3-container w3-theme-l4 w3-leftbar">
				<p>
					If the above sections mean nothing to you, don't worry - unless you're used to Bash, Python, Javascript, C/C++, C#,
					VBScript,
					Pascal, etc it won't matter until you start scripting!<br>
					If you ARE interested in learning more about programming with PowerShell try <a
						href="https://en.wikiversity.org/wiki/PowerShell" target="_blank">PowerShell on Wikiversity</a>, or if you're coming
					from Bash/Python/etc you can <a href="https://learnxinyminutes.com/docs/powershell/" target="_blank">Learn PowerShell in
						Y Minutes</a>.
				</p>
			</div>

			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<hr>
			<h4 id="concept-write">Write vs Write-Host</h4>

			<p>
				Mentioning <code>Write-Host</code> and <code>Write</code> above it's worth expanding briefly on these, and also how to
				accept user input. Normally a script
				takes its input from a file (like a .CSV file), from another command, or parameters on the command line. But sometimes being
				able to ask the user for
				input can often be beneficial (and simpler) too, that's where <code>Read-Host</code> comes in.
			</p>

			<ul>
				<li><code>Write</code> is an alias for <code>Write-Output</code> (the alias <code>echo</code> also works), and as mentioned
					above sends whatever it prints get sent
					to the Pipeline and displayed by the Shell on the Console. It's the <i>implied</i> final item in a Pipeline, even if you
					don't specify it.<br>
					That is: <code>dir | sort Length</code> and <code>dir | sort Length | Write-Output</code> are semantically the same.<br>
					If you use <code>write</code> in a Function the output goes to the Pipeline and is returned by the Function (instead of
					being displayed on the screen)</li>
				<li><code>Write-Host</code> sends whatever it prints <i>directly</i> to the Console window, bypassing the Pipeline. If you
					use it in a Function it will just
					display on the screen, it isn't placed in the Pipeline or returned.<br>
					It also has <code class="console">-ForegroundColor</code> and <code class="console">-BackgroundColor</code> options, so
					you can do:<br>
					<code>write-host -fore red -back green "It's Christmas time!"</code></li>
				<li>If you can output to the Console you should be able to input as well, and using <code>Read-Host</code> you can! You can
					even specify a prompt/question;
					the input is returned as a String, but PowerShell can convert to a number. You could ask for someone's name using:<br>
					<code>$Name = Read-Host -Promp "Please enter your name"</code> and PowerShell will wait for the operator to type
					something and press <kbd>Enter</kbd>, placing
					whatever is typed in <code class="console">$Name</code>.</li>
			</ul>

			<p>Here's two versions of the same Function, one using <code>Write-Host</code> and one using <code>Write</code> to illustrate:
			</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-light w3-threequarter">
					<h5>Write-Host vs Write in Functions:</h5>
					<div class="w3-code notranslate">
						PS C:\> # With Write-Host note that the message displays when the Function is called:<br>
						PS C:\> Function Add-Nums ($a, $b) { write-host "Adding: $a and $b."; $a + $b }<br>
						PS C:\> $c = Add-Nums 3 10<br>
						Adding: 3 and 10.<br>
						PS C:\> write "The answer is $c!"<br>
						The answer is 13!<br>
						PS C:\> # With Write instead, where the message is returned into $c<br>
						PS C:\> Function Add-Nums ($a, $b) { write "Adding: $a and $b."; $a + $b }<br>
						PS C:\> $c = Add-Nums 3 10<br>
						PS C:\> write "The answer is $c!"<br>
						The answer is Adding: 3 and 10. 13!<br>
					</div>
				</div>
			</div>

			<p>It's not that either is right or wrong, they both have their places. However, it's usually more correct to use
				<code>Write</code> and only return
				whatever should be returned from within a Function (and only use <code>Write-Host</code> to display diagnostic information.
			</p>

			<hr>
			<h3 id="final-points">Final PowerShell Points</h3>

			<p>A few other helpful things worth mentioning before finishing this PowerShell Boot Camp:
			<ul>
				<li>When working with text you will often have to replace characters or join multiple pieces (Array elements) together.
					Often you can use Methods such as <code class="console">.replace()</code> and <code class="console">.join()</code>, but
					there's also the <code class="console">-replace</code> and <code class="console">-join</code> Operators (which are very
					similar but also support <a href="https://regex101.com/" target="_blank">Regular Expressions</a>, RegEx). Examples to
					try:<br>
					<code>(dir c:\windows).Name -join "; "</code><br>
					<code>(write "My name is Jane!").replace("Jane", "Sarah")</code></li>
				<li>Note: Other useful String methods include <code class="console">.Trim()</code>, <code class="console">.ToUpper()</code>, <code class="console">.ToLower()</code>
					and more, check out:<br>
					<code>"Any string" | Get-Member</code> to see all the functions you can use!</li>
				<li>You can make a PowerShell Script by pasting all the lines you want to run into a plain text file and saving it as a .PS1
					file, then running it is like typing those commands at the prompt, one line at a time - making it easy to carry out the
					same set of commands over and over, or on different systems. If the .PS1 file is in your current directory you need to
					specify <code>.\nameOfScript.ps1</code> with the leading <code class="console">.\</code> (or use Tab Completion)</li>
				<li>You can run "DOS" batch files (.BAT or .CMD) just like you can run .EXE files from PowerShell. But if you want to run a
					PowerShell script from CMD.EXE you need to use: <code>powershell.exe -Command .\script.ps1</code></li>
			</ul>
			</p>

			<div class="w3-container">
				<div class="w3-quarter">&nbsp;</div>
				<div class="w3-half">
					<hr>
				</div>
			</div> <!-- centred half length HR -->

			<h4 id="concept-profile">Your $PROFILE</h4>

			<p>After all that, you can also customize your <code class="console">$PROFILE</code> - which is a built-in variable that points
				to a configuration file that
				PowerShell executes whenever it is started. You can see the path and filename by just typing the <code>$PROFILE</code> or
				open it up in an editor
				with something like: <code>notepad $PROFILE</code>. You can place configuration options and small "helper" functions to use
				on the command line.</p>

			<p>Your <code class="console">$PROFILE</code> is yours, it's saved in YOUR Windows Profile, so if you use any of the functions
				you add in anywhere scripts
				they won't be available on any other systems or running as any other users (such as scheduling a script to run under
				SYSTEM). You should only place
				functions/settings in there that you will use while administering a system from PowerShell, if multiple systems you'll need
				to copy it over.</p>

			<div class="w3-container">
				<div class="w3-panel w3-card w3-theme-l3 w3-threequarter">
					<h5>Sample $PROFILE for PowerShell 5.1</h5>
					<pre><code class="language-powershell"># Some configuration for the built-in PSReadline module:
# Make Up and Down arrows act more like CMD's command history:
Set-PSReadlineOption -HistorySearchCursorMovesToEnd:$true
Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward

# Some helper functions for the command line:

Function Get-OffsetDate ($Days = -7) {
	# Returns the date $Days in the past/future (default = 7 days ago)
	# Example: dir | Where LastWriteTime -gt (Get-OffsetDate -5)
	(Get-Date).AddDays($Days)
}

Function Format-Date ($Date = (Get-Date)) {
	# Returns a date in just "YYYY-MM-DD" format (default = Today)
	# Example: $TwoWeekDateStamp = Format-Date (Get-Date).AddDays(14)
	(Get-Date $Date).ToString("yyyy-MM-dd")
}

Function Truncate-String ($String, $Length) {
	# Truncates/cuts a string to Length by cutting off characters on the RIGHT
	# Example: $FirstFiveChars = Truncate-String "0123456789ABCD" 5
	if (!$String) { 
		$null			# If no string then return null
	} else {
		# Return a portion of the String, the lesser of $Length or the String's .Length
		$String.substring(0, [System.Math]::Min($Length, $String.Length))
	}
}

Function Read-Input ($Prompt, $Default = "") {
	# Returns input like Read-Host except just pressing Enter returns a $Default value
	# Example: $FileName = Read-Input -Prompt "Enter a file name" -Default "data.csv"
	$Input = Read-Host "$Prompt, or accept [$Default]"
	if ($Input -eq "") { $Default } else { $Input }
}
</code></pre>
				</div>
			</div>

			<p>Feel free to use any of these, but if you use them in scripts you'll need to copy and paste them into the script before
				calling them.</p>

			<p>Of course this is just scratching the surface of PowerShell, but it should be enough to get you started!</p>

		</div><!-- Page Content ends here -->

		<!-- Footer -->
		<footer class="w3-container w3-theme" style="padding:16px 32px">
			<p>Thanks for reading! I hope this has been helpful. Return to all my <a href="https://github.com/sansbacher/docs">Docs</a> on
				GitHub.</p>
			<p class="w3-small">HTML and CSS theme (with some modifications) from <a href="https://www.w3schools.com/w3css/"
					target="_blank">W3 Schools</a>. W3.CSS is free to use, no license is necessary. Simple and works. Syntax highlighting by
				<a href="https://prismjs.com/" target="_blank">Prism</a>.</p>
		</footer>

	</div><!-- Main div for the body End -->

	<script src="../assets/js/sa-custom.js"></script><!-- Custom scripts loaded here, to ensure page is fully loaded -->
	<script src="../assets/js/prism.js"></script>
</body>

</html>