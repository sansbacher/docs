<!DOCTYPE html>
<html lang="en">
<head>
	<!-- Update these for each page -->
	<title>PowerShell CLI Boot Camp</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="keywords" content="command line,powershell,cmd,dos,console,shell,terminal,command,cmdline,commandline,howto,how-to,guide,commands,admin,administrator,windows,win32">
	<meta name="description" content="A commandline tutorial for PowerShell, CMD, and the CLI in general for Windows Admins">
	<meta name="author" content="Saul Ansbacher">
	<!-- Based on the "Material Design" W3.CSS Demo, with some changes, from www.w3schools.com. Simple and works. -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
	<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue-grey.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!-- Some custom CSS overrides: -->
	<link rel="stylesheet" href="../css/sa-custom.css">
</head>
<body>
	<nav class="w3-sidebar w3-bar-block w3-collapse w3-animate-left w3-card" style="z-index:3;width:250px;" id="mySidebar">
	  <a class="w3-bar-item w3-button w3-hide-large w3-large" href="javascript:void(0)" onclick="w3_close()">Close <i class="fa fa-remove"></i></a>
	  <!-- Side Nav Bar items -->
	  <a class="w3-bar-item w3-button" href="index.html">CLI Home</a>
	  <a class="w3-bar-item w3-button" href="cli-basics.html">CLI Basics</a>
	  <a class="w3-bar-item w3-button" href="ps-essentials.html">PowerShell Essentials</a>
	  <a class="w3-bar-item w3-button" href="cmd-essentials.html">CMD/DOS Essentials</a>
	  <a class="w3-bar-item w3-button" href="cli-keystrokes.html">CLI Keystrokes</a>
	  <a class="w3-bar-item w3-button" href="cli-symbols.html">CLI Symbols</a>
	  <a class="w3-bar-item w3-button" href="basic-file-sys-commands.html">Basic File Sys Commands</a>
	  <a class="w3-bar-item w3-button" href="cli-tasktest.html">CLI Task Test</a>
	  <a class="w3-bar-item w3-button" href="console-commands.html">Common Console Commands</a>
	  <a class="w3-bar-item w3-button w3-theme" href="ps-bootcamp.html">PowerShell Boot Camp</a>
	  <a class="w3-bar-item w3-button" href="cmd-bootcamp.html">CMD/DOS Boot Camp</a>
	  <a class="w3-bar-item w3-button" href="additional-topics.html">Additional Topics</a>
	  <a class="w3-bar-item w3-button" href="https://github.com/sansbacher/docs">Return to Docs</a>
	</nav>

	<div class="w3-overlay w3-hide-large w3-animate-opacity" onclick="w3_close()" style="cursor:pointer" id="myOverlay"></div>

	<div class="w3-main" style="margin-left:250px;"><!-- Main div for the body Start -->

	<!-- Change both of these to change the Page Header -->
	<div id="myTop" class="w3-container w3-top w3-theme w3-large">
	  <p><i class="fa fa-bars w3-button w3-theme w3-hide-large w3-xlarge" onclick="w3_open()"></i>
	  <span id="myIntro" class="w3-hide">PowerShell Command Prompt Boot Camp</span></p>
	</div>
	<header class="w3-container w3-theme" style="padding:64px 32px">
	  <h1 class="w3-xxxlarge">PowerShell Command Prompt Boot Camp</h1>
	</header>

	<div class="w3-container" style="padding:32px;padding-right:5%"><!-- Page Content starts here -->

	<h2>A PowerShell Command Line Boot Camp</h2>

	<p>This section will give a brief boot-camp / accelerated crash course to get up to speed on PowerShell quickly. It won't be very in depth, but it should provide enough info you can get by or at least search for more in-depth pages about a certain topic. It also won't teach you how to <i>program</i> scripts or some of the PowerShell best practices or gotchas - it's a basic "get started fast" guide.</p>
	
	<p>I assume you can complete the <a href="cli-tasktest.html">CLI Task Test</a>, if not run through Zen's <a href="https://learnpythonthehardway.org/book/appendixa.html" target="_blank">CLI Crash Course</a> first. Most what you may know about the CMD/"DOS" Prompt may also be useful. This will just be a surface-level guide, not a deep-dive. Enough to help point you in the right direction and know what to Google if you get stuck. For the basics see the <a href="ps-essentials.html">PowerShell Essentials</a> page.</p>

	<h3>PowerShell Commands</h3>

<p>PowerShell commands (officially called cmdlets) are generally always of the form <i>Verb-Noun</i> or <i>Action-Subject</i>, and the Noun or Subject will have several Verb/Action related commands, such as <code>Get-Content</code>, <code>Set-Content</code>, <code>Add-Content</code>, and <code>Clear-Content</code> to get the contents of a file, write a file, add to a file, and empty a file.
<ul>
<li><code class="console">Get-*</code> commands are usually always safe to run as they just <i>retrieve</i> some information</li>
<li><code class="console">Set-*</code> commands are used to <i>change</i> or to <i>set</i> some value(s)</li>
<li><code class="console">New-*</code> commands are used to <i>create</i> something new (like a folder or other object)</li>
<li><code class="console">Remove-*</code> commands <i>delete</i> something</li>
<li>Not every Verb is available (or would make sense) for every Noun/Subject, but usually they are in matched pairs, such as Get-/Set- or Export-/Import-, etc<br>
	There are many standard Verbs, try <code>Get-Verb</code> to see them all - but people still use non-standard Verbs too.</li>
</ul>
</p>

<p>PowerShell commands/cmdlets always use a single dash <kbd>-</kbd> to indicate options/paramters/switches/arguments, such as <code class="console">-Identity</code> or <code class="console">-Properties</code>. Any value comes after, such as: <code class="console">-Identity jsmith</code>. PowerShell commands/cmdlets and options/parameters are <i>not</i> case sensitive, but usually displayed using PascalCase so words smooshed together AreEasierToRead.</p>

<p>PowerShell cmdlets come in various modules: many of which are included with Windows/PowerShell, come with other programs (like Active Directory or SQL Server), or can be downloaded from the <a href="https://www.powershellgallery.com/" target="_blank">PowerShell Gallery</a>. Load a module with <code>Import-Module</code> (though often just using a cmdlet will auto-load the module in PowerShell 3.0+) and install a module with <code>Install-Module</code>. See all the modules installed on your system with: <code>Get-Module -ListAvailable</code><br>
&nbsp; &rarr; Sometimes there are prefixes to the Nouns/Subjects to group commands, such as <code>Get-ADUser</code>, <code>Set-ADComputer</code>, <code>Remove-ADGroup</code> each having an "AD" prefix.</p> 

	<hr>
	<h3>The Three Most Useful Commands</h3>

<p>Because PowerShell is very regular and discoverable the 3 most useful commands to initially learn are listed here:</p>

<ul class="w3-ul"><li><p><code>Get-Help</code> (alias = <code>help</code>) to display the Help Text for any command, cmdlet, or just about anything. Using <code class="console">-full</code> will usually give you detailed help and examples, such as: <code>help get-content -full</code> (you can skip right the examples with <code class="console">-Examples</code>, as in: <code>help get-content -examples</code>)
</p><p>
You can also get help on various internal aspects of PowerShell, they all start with <i>about_</i> such as <code>help about_variables</code> or try <code>help about_</code> to see a list of all internal help files.</p></li>

<li><p><code>Get-Command</code> (alias = <code>gcm</code>) to search for and find various commands, cmdlets, functions, etc. Similar to CMD's <code>where.exe</code> but with much more flexibility and fine-grained control. You can use <code class="console">-CommandType</code> to search for only certain commands or functions, or <code class="console">-Module</code> to limit searching to a certain Module as in <code>gcm -module ActiveDirectory</code>
</p><p>
But just filtering on the Name is simplest: see all the "Get-" commands on your system try <code>gcm get-*</code> or if you want to see all Verbs/Actions you can perform on Services try: <code>gcm *-Service</code> or to see any command pertaining to "computers" try <code>gcm *computer*</code></p></li>

<li><p><code>Get-Member</code> (alias = <code>gm</code>) to get all the <i>Properties</i> and <i>Methods/Functions</i> that are returned from a command/cmdlet or belonging to a <i>Type</i> or <i>Variable</i>. Because PowerShell is "all objects" every <i>Object</i> can have hidden Properties (values) or Methods/Functions (actions you perform). Most of these are all .NET based since PowerShell relies on the .NET Framework (or .NET Core).</p>
<p>A command like <code>Get-Date</code> returns the current Date and Time, but the value returned isn't just a text string of characters, you can see the Type and all the various Properties and methods with: <code>Get-Date | gm</code> which will show that its Type is <i>System.DateTime</i>, and it has over 50 Properties and Methods that contain just the Seconds, Hours, Days, or Months and let you convert the DateTime to different formats or Add days, hours, months, etc to get a new DateTime. (we'll see how to access these Properties/Methods below)</p></li></ul>

	<hr>
	<h3>The Three Most Useful Concepts</h3>

<p>Relatedly, the 3 most useful concepts in PowerShell are: Variables, Objects, and the Pipeline. We'll cover these in greater detail in the next sections.</p>

	<h4>Variables</h4>

<p>Since everything is an <i>Object</i> (which will be discussed in the next section): a PowerShell command can return a lot of data, you can use <i>Variables</i> to store this data and access it again later; or create your own variables to avoid having to re-type the same thing over and over. There are some built-in and automatic variables. Think of a variable as a bucket with a label: the label is the name of the variable and the bucket holds the value. You retrieve the value by referencing the bucket by the name on the label. If you change the contents of the bucket: anywhere after it is referenced by name will use the new value.</p>
<ul><li>Variable names always start with a dollar sign <kbd>$</kbd>, such as <code class="console">$Username</code> or <code class="console">$SomeLocation</code></li>
<li>You create a variable by assigning a value to the name with the equals sign <kbd>=</kbd> such as: <code>$Username = "jsmith"</code> or <code>$SomeLocation = "c:\temp\folder"</code></li>
<li>You can also fill a variable with the results of a command, such as: <code>$today = Get-Date</code> (the right hand side is evaluated first and then assigned to the variable on the left)</li>
<li>To use a variable just use its name (eg. <code class="console">$SomeLocation</code>) such as: <code>$ListOfFiles = dir $SomeLocation</code> (now <code class="console">$ListOfFiles</code> will contain a list of all the files located in <code class="console">$SomeLocation</code>)</li>
<li>One special built-in variable is <code class="console">$null</code> which represents <i>nothing</i> or an empty variable, you can clear a variable by setting it to <code class="console">$null</code> such as: <code>$Username = $null</code></li>
</ul>

<p>Often a cmdlet will return more than one value (such as many files in a directory, many AD Users, many Processes, etc) in those cases the results will be an <i>Array</i> which is List or Collection of items. An Array can also be assigned to a variable in exactly the same way. However the variable name (eg. <code class="console">$ListOfFiles</code>) will point to the Array, not one particular item in the array. To select just one item from the Array you use an <i>Index</i> number - which starts at 0, in <i>[square brackets]</i> after the Array variable name.</p>
<ul>
	<li>Thus if <code class="console">$ListOfFiles</code> has has 10 files, then the first is <code class="console">$ListOfFiles[0]</code> and the last (the 10th) is <code class="console">$ListOfFiles[9]</code></li>
	<li>Always be mindful that Array indexes run from 0 to <i>Total - 1</i></li>
	<li>Think of an Array as a clothesline with a bunch of variable buckets hanging from it. The clothesline has a label with the name of the array, and each bucket has only a number on its label.</li>
</ul>

<p>It's also worth briefly noting that variables have a <i>Type</i> in addition to a <i>Name</i> and a <i>Value</i> - the Type is the sort of Value the bucket holds. Common types are <i>String</i> (a sequence of characters, <i>"such as a sentence in quotes"</i>), <i>Int</i> (for Integer, a number without a decimal place: <i>0, 1, -6, 689</i>, but not 1.5 or 3.14), <i>Float</i> (for floating point, a number with a decimal place: <i>0.0002, -0.5, 1.11178, 2.0, 3.14</i>), <i>Boolean</i> (a value that is only either <code class="console">$True</code> or <code class="console">$False</code> - two special variables that represent <i>True</i> or <i>False</i>), <i>DateTime</i> (a Date and/or Time value, such as returned by <code>Get-Date</code>), and any other valid .NET type. Think of the Type as the Colour of the variable bucket: there's a name of a variable but also a colour denoting if it's holding text, numbers, dates, etc.
</p>
<ul><li>Normally the Type is not important as PowerShell has Dynamic Typing and will convert between types as needed.</li>
<li>But sometimes you need to be explicit about the Type or you need to be aware of the Type or you could find strange things happening.</li>
<li>For example: 5 is an Int (integer number) but <code class="console">"6"</code> is a very short 1-character String. Try adding them to together in PowerShell, note the order makes a difference: (you can just type these at the <code class="console">PS C:\></code> prompt.<br>
	<code>5 + "6" = 11</code> (because "6" is converted to the number 6), but <code>"6" + 5 = "65"</code> (because now 5 gets converted to the string "5" and concatenated/appended to "6" creating a 2-character String)</li>
<li>An <i>Array</i> is a Type as well: an Object that is a List or Collection of other Variables</li>
</ul>

<h4>Objects</h4>

<p>If PowerShell is all about Objects, what's an Object? An <i>Object</i> is "Structured Data + Methods to work with that Data". Think of an Object as a Large Bucket with several smaller Buckets inside plus the Tools to "do things with those buckets". The smaller buckets are <i>Properties</i> (the Data - basically a bunch of related variables) and the Tools are <i>Methods</i> (or Functions, that can do things with the Properties/variables). Objects are structured because every Object also has a Type and all Objects of the same Type follow the same structure, like a Template (having the same Properties and Methods available as the Template they were created from).</p>

<p>Object variables have their name on the Large Bucket that you can pick (like <code class="console">$UserObject</code>) but the Property and Method names are set by the template Type for that sort of Object.<br>
You can reference the Properties and Methods with "dot notation" - by using the Object's variable name, a dot, and the Property or Method. Eg: <code class="console">$Object.Property</code> or <code class="console">$Object.Method()</code><br>
&nbsp; &rarr; Properties are just variables and hold values, sometimes you can <i>set</i> them, other times you can only <i>get</i> them (if they are read-only).<br>
&nbsp; &rarr; Methods are <i>functions</i> that perform actions, possibly returning a value; you need to use <i>(parentheses)</i> to call a function, and pass any parameters inside the parentheses like: <code class="console">$Object.Method(parameter1, parameter2)</code></p>

<ul>
	<li>Example Properties on an <i>AD User object</i> returned from <code>Get-ADUser</code>, such as: <code>$UserObject = Get-ADUser -Identity jsmith</code> might be:<br>
		<code class="console">$UserObject.Surname</code> might return "Smith"<br>
		<code class="console">$UserObject.GivenName</code> might return "Jane"</li>
	<li>Example Methods on a <i>DateTime object</i> returned from <code>Get-Date</code>, such as <code>$Today = Get-Date</code> might be:<br>
		<code class="console">$Today.ToString()</code> would return the date and time you ran Get-Date such as "2/24/2020 10:20:42 PM"<br>
		But <code class="console">$Today.ToString("yyyy-MM-dd")</code> would tell the ToString() function to return only the date in YYYY-MM-DD format, such as "2020-02-24"<br>
		And <code class="console">$Today.AddDays(4)</code> would return the date exactly 4 days from now on Feb 28.</li>
	<li>It's very common to have an <i>Array of Objects</i> (since almost everything except simple Strings and numbers are Objects). As the Array type is also an Object itself it has Properties and Methods too! One of the most useful Properties of an Array is the Length - how many items are in the Array<br>
		If <code class="console">$ListOfFiles</code> is an Array of 10 items/files then <code class="console">$ListOfFiles.Length</code> would return 10<br>
		But note: the last/final <i>Index</i> of the Array would still be <code class="console">$ListOfFiles[9]</code>. The Length is a count of how many items there are, starting at 1: it could be 0 (for no items), or 1, 2, 3, 10, or hundreds of items. But the <i>Index</i> runs from <i>[0]</i> to <i>[Length -1]</i></li>
</ul>

<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	You can use <code>Get-Member</code> to see all the Properties and Methods an Object contains.<br>
	Can you convert an Int (number) to a String? Can you add years to a DateTime? Is there an Email Address Property on an AD User Object?<br>
	Use <code>Get-Member</code> to find out! Example: <code>$UserObject | Get-Member</code>, or <code>Get-Member -InputProperty $Today</code>, or even: <code>12345 | Get-Member</code>
</p></div>

<br>
<div class="w3-container"><div class="w3-quarter">&nbsp;</div><div class="w3-half"><hr></div></div>		<!-- centred half length HR -->

<p>Often you need to access Properties, Methods, or even just evaluate a PowerShell expression, variable or command <i>within</i> another command or context. You can use subexpressions to do this by enclosing the command/variable/expression in brackets like: <code class="console">(Some-Command)</code> and then you can access Properties/Methods, like: <code class="console">(Some-Command).OneProperty</code></p>

<ul>
	<li>You <b>can't</b> do: <i>Get-Date.ToString("yyyy-MM-dd")</i></li>
	<li>So you can either assign <code>Get-Date</code> to a variable such as <code class="console">$Today</code> (see above), <b>or</b> enclose it in brackets: <code>(Get-Date).ToString("yyyy-MM-dd")</code></li>
	<li>You can access Properties too: <code>(Get-ADUser -Identity jsmith).Surname</code></li>
	<li>If there's more than one command inside the brackets, OR the command is inside a "double quoted string" then add a dollar sign <kbd>$</kbd>to the front: <code>"Today's date is $($Today = Get-Date; $Today) and tomorrow is $($Today.AddDays(1))."</code><br>
		Note: if you want to use Variables within Strings you need to use <i>"double quotes"</i>, if you use <i>'single quotes'</i> you'll see the name of the variable instead</li>
</ul>

	<div class="w3-container">
		<div class="w3-panel w3-card w3-theme-light w3-threequarter">
		  <h5>An Example of Variables with "double" and 'single' quotes:</h5>
		  <div class="w3-code notranslate">
			PS C:\> $Today = Get-Date<br>
			PS C:\> # With "double quotes" it will resolve the $Today variable:<br>
			PS C:\> "It is $Today"<br>
			It is 02/24/2020 12:13:17<br>
			PS C:\> # With 'single quotes' it will print exactly as written:<br>
			PS C:\> 'It is $Today'<br>
			It is $Today<br>
		  </div>
		</div>
	</div>

<h4>The Pipeline</h4>

<p>The PowerShell <i>Pipeline</i> is what allows you to link commands (or Variables) together to process, filter, or otherwise do something with the values. The Pipeline is denoted by the vertical bar or Pipe character: <kbd>|</kbd>, which separates commands/cmdlets, expressions or variables. Each section of the Pipeline feeds the next: <i>the Output of one command becomes the Input of the next</i>. Almost all PowerShell commands/cmdlets and many scripts output Objects that can be accepted as input via the Pipeline by other commands/cmdlets/scripts - the Pipeline passes Objects. You can think of it as an unnamed Array of Objects where the current Object is represented by the special variable: <code class="console">$_</code> though often you don't need to reference individual elements of the Pipeline since by default commands will work on <i>all</i> elements of the Pipeline. Usually a command changes or filters (narrows) the Output as compared to the Input. You can have as many 'sections' of the Pipeline as you want, but unwieldy commands can be shortened by using Variables. Be careful mixing non-PowerShell (regular Windows Console CMD commands) and the PowerShell Pipeline: non-PowerShell commands output plain text, <i>not</i> objects!</p>

<p>Some common simple commands that work with the Pipeline are: <code>Sort-Object</code>, <code>Measure-Object</code>, <code>Group-Object</code> (usually just referenced by their aliases: <code>Sort</code>, <code>Measure</code>, and <code>Group</code>). By default the final result of the Pipeline is displayed on the screen, so you'll see the results.
<ul>
	<li>How many files in a folder: <code>dir c:\windows | Measure</code></li>
	<li>Files ordered by size: <code>dir c:\windows | Sort Length</code></li>
	<li>How many of each file type: <code>dir c:\windows | Group Extension | Sort Name</code></li>
</ul>
</p>

<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	Remember you can use <code>Get-Command</code> to see what other commands deal with "Objects", such as <code>Get=Member *-Object</code>
</p></div>

<p>Other common Pipeline commands involve displaying information: <code>Format-List</code>, <code>Format-Table</code> (usually just <code>fl</code> and <code>ft</code>), <code>Out-String</code> or <code>Out-GridView</code> -- these almost always come at the end of the Pipeline:
<ul>
	<li>List more details on files: <code>dir c:\windows | fl</code> (you can still add <code class="console"> | more</code> after to show a page at a time)</li>
	<li>They can be combined and displayed in a pop-up window: <code>dir c:\windows | sort Length | Out-GridView</code></li>
</ul>
Because of the regular and non-cryptic nature of PowerShell you can probably guess what most of these do even without using <code>help</code> with them. For example, the last one is literally "directory of C:\Windows, sorted by file Length, whose output goes into a GridView (a kind of pop-up list of data)"
</p>

<p>Saving/exporting (or reading/importing) data to/from files using Pipeline data is possible too: <code>Set-Content</code>, <code>Add-Content</code>, <code>Out-File</code>, <code>Export-Csv</code>, <code>Get-Content</code>, <code>Import-Csv</code>, <code>ConvertTo-Html</code>, and <code>ConvertFrom-Json</code> -- usually you want the raw data to be exported, so <i>don't</i> place these after <code>Format-List</code> or <code>Format-Table</code>
<ul>
	<li>Save the results to a file as .TXT or a .CSV: <code>dir c:\windows | Set-Content c:\temp\output.txt</code> OR <code>dir c:\windows | Export-Csv -NoType c:\temp\output.csv</code></li>
	<li>You can load the .CSV file back with: <code>$Results = Import-Csv c:\temp\output.csv</code></li>
</ul>
</p>

	<p>Remember, use <code>Get-Help</code> (maybe with <code class="console">-Full</code> or <code class="console">-Examples</code>) to look up what these commands do, what the Required or Optional paramters do (such as what <code class="console">-NoType</code> does for <code>Export-Csv</code> -- remember you only need to specify enough to uniquely identify paramaters). </p>

<div class="w3-container"><div class="w3-quarter">&nbsp;</div><div class="w3-half"><hr></div></div>		<!-- centred half length HR -->

<p>Two of the most important, and common, <i>Pipeline</i> commands are <code>Where-Object</code> (or just <code>Where</code>, or even just a single question mark <kbd>?</kbd> as an alias) which <i>filters which Objects to pass along the Pipeline</i> (that is: only pass along Objects which match some search/filter criteria). And <code>Select-Object</code> (or just <code>Select</code>) which <i>filters which Properties of Objects are passed along the Pipeline</i> (that is: only pass along Properties that are listed, no others).<br>
 &nbsp; &rarr; <code>Where</code> filters Objects, <code>Select</code> filters Properties (of Objects)<br>
Combined with other commands you can filter/choose which Objects or Properties to keep and which to discard, depending on what you want to do.</p>

<p><code>Where</code> uses either the older/classic script-block format (which still allows more complex filters) or the newer (PS 3.0+) native format. In either case you choose aspects (usually Properties) of Objects and those Objects that match are passed along and those that don't are discarded.
<ul>
	<li>You will need to use one or more <i>Operators</i> such as <code class="console">-and</code>, <code class="console">-or</code>, <code class="console">-not</code> (or the exclamation <kbd>!</kbd> character), <code class="console">-eq</code> (equals), <code class="console">-ne</code> (not equals), <code class="console">-gt</code> (greater than), <code class="console">-ge</code> (greater than or equal to), <code class="console">-lt</code> (less than), <code class="console">-le</code> (less than or equal to), <code class="console">-like</code>, <code class="console">-notlike</code>, <code class="console">-contains</code>, <code class="console">-in</code>, and several others. These work like in algebra and return <code class="console">$True</code> or <code class="console">$False</code>.<br>
	In the same way that <i>5 > 3 = True</i>, <code>5 -gt 3</code> is <code class="console">$True</code> (because 5 is greater than 3).<br>
	They all start with a dash: <kbd>-</kbd>. More information on <a href="https://ss64.com/ps/syntax-compare.html" target="_blank">Comparison Operators</a>.</li>
	<li>New <code>Where</code> format: <code>dir c:\windows | Where LastWriteTime -lt "2019/01/01" | Measure</code> (to see how many old files there are)</li>
	<li>Older <code>Where</code> format: <code>dir c:\windows | Where {$_.LastWriteTime -lt "2019/01/01"} | Measure</code> (note the <code>Where</code> filter is in <i>{curly braces}</i> and needs <code class="console">$_</code> to reference Objects in the Pipeline)</li>
</ul>
</p>

<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	<b>Note</b>, in PowerShell 'equals', 'not equals', 'greater than', and 'less than' are consistent in using <i>-something</i> because =, &gt;, and &lt; are used to assign variables or redirect output.<br>
	You cannot use also them to check if something is equal or greater than something. Use <code class="console">-eq</code>, <code class="console">-ne</code>, <code class="console">-gt</code>, <code class="console">-lt</code>, etc
</p></div>

<p><code>Select</code> uses names of Properties (including partial matches using wildcards, where <kbd>*</kbd> = any characters) to filter what results get passed along. You can list one or more Properties, or Expand a Property if it contains multiple values or SubProperties; or choose just the First or Last number of items, or only return Unique values from a collection/array of Objects. Generally all the Objects are passed along, just not all their Properties - use <code>Where</code> to filter whole Objects.</p>

<p><ul>
	<li>To see only certain Properties (including one, like <i>FullName</i>, that isn't displayed by default): <code>dir C:\Windows | select Name, Fullname, LastWriteTime</code></li>
	<li>To see all the various "Time" Properties: <code>dir C:\Windows\notepad.exe | select Name, *Time*</code><br>
		With more than 4 properties often the default output style becomes List (aka <code>Format-List</code> or <code>fl</code>) rather than Table (aka <code>Format-Table</code> or <code>ft</code>), so seeing one item is easier than all.<br>
		Most Cmdlets have a default set of Properties to display, using <code class="console">| select *</code> you can see them <i>all</i>.</li>
	<li>To see all the available Properties: <code>dir C:\Windows\notepad.exe | select *</code></li>
	<li>If a Property has multiple values or SubProperties (often appearing as just a Type) you can dig deeper, compare these: <code>dir C:\Windows\notepad.exe | select VersionInfo</code> and <code>dir C:\Windows\notepad.exe | select -expand VersionInfo</code><br>
		And even <code>dir C:\Windows\notepad.exe | select -expand VersionInfo | select *</code></li>
	<li>You can also limit by <code class="console">-First</code> or <code class="console">-Last</code>, such as: <code>dir c:\windows | select -last 3</code></li>
	<li>Finally, you can use <i>Calculated Properties</i> with <code>Select</code> (especially useful with <code>Export-Csv</code> if you see a Type or something else unhelpful, but it displays correctly at the Console because it's multi-valued). Calculated Properties require a <i>Hashtable</i> with <i>Name</i> and <i>Expression</i> Keys (we haven't covered Hashtables, they're similar to Arrays but are made up of <i>Key/Value pairs</i>). An example would be:<br>
		<code>dir c:\windows | select Name, @{ Name = 'LastWriteDay'; Expression = {$_.LastWriteTime.ToString("yyyy-MM-dd")} }, LastWriteTime</code><br>
		Which displays the Name and the usual LastWriteTime, but also a new, Calculated Property, called <i>LastWriteDay</i> which is only the Date portion of LastWriteTime.</li>
	<li>Many, but not all, of <code>Select</code>'s functions can be done directly with <code>ft</code> / <code>fl</code> as a convenience, this avoids needing to do: <code>dir | select Name, LastWriteTime | fl</code>, you can just do: <code>dir | ft Name, LastWriteTime</code></li>
</ul></p>

<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	<b>Note</b>, because <code>Select-Object</code> is all about Objects it can get you into trouble if you to try to use it with the output from regular Windows Console CMD .EXE commands.<br>
	Non-PowerShell commands output plain-text, which isn't Objects. To filter plain-text strings use <code>Select-String</code> (alias is <code>sls</code>).<br>
	Where <code>manage-bde.exe -status c:</code> will show the BitLocker status of the C: drive, you CAN'T filter on the "<i>Conversion Status: &nbsp; &nbsp;Fully Decrypted</i>" line with this:<br>
	<code>manage-bde.exe -status c: | select "Conversion Status"</code><br>
	But you CAN with <code>Select-String</code>:<br>
	<code>manage-bde.exe -status c: | select-string "Conversion Status"</code>
</p></div>

	<hr>
	<h3>Advanced Control Structures</h3>

<p>PowerShell has many advanced control structures as well, but because this document is about the basic Command Line usage and not Programming/Scripting we'll just mention a few here. You will need to learn these (especially <code>foreach</code> and <code>if</code>) to create scripts or solve more advanced problems with PowerShell. For now, focus on being comfortable with PowerShell and the Command Line in general.</p>

<p>The Pipeline cmdlet: <code>Foreach-Object</code> (or the aliases: <code>foreach</code> or even just the percent sign <kbd>%</kbd> by itself) to do something to everything in an Array/Collection in the Pipeline, where <code class="console">$_</code> represents the current Item/Object being processed, like with <code>Where</code>, for example: <code>dir | foreach { write "Here is a file: $($_.Name)" }</code></p>

<p>The confusingly named PowerShell statement: <code>foreach</code> which is very similar to <code>Foreach-Object</code> (especially since alias for one is the same as the other - PowerShell figures out which) but the <code>foreach</code> doesn't use the Pipeline but names each item it works on (the <code class="console">$file</code> variable in the example below) instead of using <code class="console">$_</code>.</p>

<p>Which <code>foreach</code> method you use doesn't matter a lot, one will make more sense in some situations and the other in other situations. Use whichever makes the most sense at the time - ie. are you working with data in the Pipeline? Within .PS1 scripts the <code>foreach</code> statement is often used to do muliple things to each item in the array. Have a look at the example below - they both produce the same output.</p>

	<div class="w3-container">
		<div class="w3-panel w3-card w3-theme-light w3-threequarter">
		  <h5>An Example of Variables with "double" and 'single' quotes:</h5>
		  <div class="w3-code notranslate">
			PS C:\> $AllFiles = dir c:\windows<br>
			PS C:\> # With the Foreach-Object cmdlet you process via the pipline (input and output):<br>
			PS C:\> $AllFiles | foreach { write "Here is a file: $($_.Name)" }<br>
			Here is a file: addins<br>
			Here is a file: ADFS<br>
			Here is a file: etc, etc<br>
			PS C:\> # With the foreach statement you declare a variable to work with the Array, no Pipeline:<br>
			PS C:\> foreach ($file in $AllFiles) { write "Here is a file: $($file.Name)" }<br>
			Here is a file: addins<br>
			Here is a file: ADFS<br>
			Here is a file: etc, etc<br>
		  </div>
		</div>
	</div>

<p>The conditional <code>IF</code>/<code>ELSE</code> statement, which uses <i>Conditionals</i> like <code>Where</code> does, is used for branching and making logical decisions. You can decide to do something IF a certain condition is true or ELSE do another things. A script that is just a collection of commands saves you from having to type them all, a script that uses variables makes it easier to maintain and update, a script that uses loops (such as above) can do the same thing to all Objects in an Array - but a script that can make <i>decisions</i> can be very powerful. An example of a <code>if</code> is below:</p>

	<div class="w3-container">
		<div class="w3-panel w3-card w3-theme-light w3-threequarter">
		  <h5>An Example of Variables with "double" and 'single' quotes:</h5>
		  <div class="w3-code notranslate">
			PS C:\> $value = 25<br>
			PS C:\> # Use IF to decide what to print:<br>
			PS C:\> if ($value -lt 10) { write "$value is a small number" } else { write "$value is a big number" }<br>
			25 is a big number<br>
		  </div>
		</div>
	</div>

	<br>
<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	Note: in the above two examples (for <code>foreach</code> and <code>if</code>) there's a <i>Script Block</i> in <i>{curly braces}</i> with commands that are run.<br>
	You can have multiple commands within Script Blocks, seperated by semi-colons <kbd>;</kbd> or within a .PS1 script by putting commands on seperate lines.
</p></div>

<p>There's also <code>For</code> loops, <code>Do</code> <code>While</code> or <code>Until</code> loops, <code>Switch</code> statements, and <i>Functions</i>. These are all beyond the scope of this document, but custom functions allow you to encapsulate common commands into a subroutine, where any output in the Pipeline is returned. This often causes headaches for people coming from other scripting languages, so it's worth noting (in case you are used to another programming/scripting language):
<ul>
<li>It's important to know: <code>Write "Some text."</code> will output via the Pipeline (and by default display on the screen), whereas <code>Write-Host "Some text."</code> will not output via the Pipeline - it displays directly on the screen.</li>
<li>A common cause of frustration with Functions is not understanding that they are designed to <i>work with the Pipeline</i> and getting unexpected output returned is a common mistake by mixing up <code>write</code> and <code>write-host</code></li>
<li>And while there is a <code>return</code> statement it's not needed as <i>anything</i> output to the Pipeline (such as by <code>write</code>) is returned by a function.</li>
<li>Also: unlike calling a Method on an Object you don't use <i>(brackets)</i> with functions - which are like cmdlets, you just pass arguments like:<br>
	<code>My-Function $Param1 "value 2" -Switch3</code> do not do this: <i>My-Function ($Param1, "value 2", -Switch3)</i> - that will create an Array!</li>
</ul></p>

<div class="w3-container w3-theme-l4 w3-leftbar"><p>
	If the above means nothing to you, don't worry - unless you're used to Bash, Python, Javascript, C/C++, C#, VBScript, Pascal, etc it's not meant to!<br>
	If you ARE interested in learning more about programming with PowerShell try <a href="https://en.wikiversity.org/wiki/PowerShell" target="_blank">PowerShell on Wikiversity</a>, or if you're coming from Bash/Python/etc you can <a href="https://learnxinyminutes.com/docs/powershell/" target="_blank">Learn PowerShell in Y Minutes</a>.
</p></div>

	<hr>
	<h3>Final PowerShell Points</h3>

<p>A few other helpful things worth mentioning before finishing this PowerShell Boot Camp:
<ul>
<li>When working with text you will often have to replace characters or join multiple pieces (Array elements) together. Often you can use Methods such as <code class="console">.replace()</code> and <code class="console">.join()</code>, but there's also the <code class="console">-replace</code> and <code class="console">-join</code> Operators (which are very similar but also support <a href="https://regex101.com/" target="_blank">Regular Expressions</a>, RegEx). Examples to try:<br>
	<code>(dir c:\windows).Name -join "; "</code><br>
	<code>(write "My name is Jane!").replace("Jane", "Sarah")</code></li>
<li>You can make a PowerShell Script by pasting all the lines you want to run into a plain text file and saving it as a .PS1 file, then running it is like typing those commands at the prompt, one line at a time - making it easy to carry out the same set of commands over and over, or on different systems. If the .PS1 file is in your current directory you need to specify <code>.\nameOfScript.ps1</code> with the leading <code class="console">.\</code> (or use Tab Completion)</li>
<li>You can run "DOS" batch files (.BAT or .CMD) just like you can run .EXE files from PowerShell. But if you want to run a PowerShell script from CMD.EXE you need to use: <code>powershell.exe -Command .\script.ps1</code></li>
</ul>
</p>

	</div><!-- Page Content ends here -->

	<!-- Footer -->
	<footer class="w3-container w3-theme" style="padding:16px 32px">
	  <p>Thanks for reading! I hope this has been helpful. Return to all my <a href="https://github.com/sansbacher/docs" >Docs</a> on GitHub.</p>
	  <p class="w3-small">HTML and CSS theme (with some modifications) from <a href="https://www.w3schools.com/w3css/" target="_blank">W3 Schools</a>. W3.CSS is free to use, no license is necessary. Simple and works.</p>
	</footer>
		 
	</div><!-- Main div for the body End -->

	<script>
		// These came from the w3schools.com Template as well:
		//
		// Open and close the sidebar on medium and small screens
		function w3_open() {
		  document.getElementById("mySidebar").style.display = "block";
		  document.getElementById("myOverlay").style.display = "block";
		}
		function w3_close() {
		  document.getElementById("mySidebar").style.display = "none";
		  document.getElementById("myOverlay").style.display = "none";
		}

		// Change style of top container on scroll
		window.onscroll = function() {myFunction()};
		function myFunction() {
		  if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
			document.getElementById("myTop").classList.add("w3-card-4", "w3-animate-opacity");
			document.getElementById("myIntro").classList.add("w3-show-inline-block");
		  } else {
			document.getElementById("myIntro").classList.remove("w3-show-inline-block");
			document.getElementById("myTop").classList.remove("w3-card-4", "w3-animate-opacity");
		  }
		}
	</script>
		 
</body>
</html> 
